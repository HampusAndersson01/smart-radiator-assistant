{
  "name": "Smart Radiator Training",
  "nodes": [
    {
      "parameters": {
        "url": "={{ $env.HOME_ASSISTANT_URL }}/api/states",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.HOME_ASSISTANT_TOKEN }}"
            }
          ]
        },
        "options": {}
      },
      "id": "REPLACE_WITH_UUID_1",
      "name": "Fetch Home Assistant States",
      "type": "n8n-nodes-base.httpRequest",
      "position": [224, 0],
      "typeVersion": 4.2
    },
    {
      "parameters": {
        "url": "={{ $env.AI_SERVICE_URL }}/",
        "options": {}
      },
      "id": "REPLACE_WITH_UUID_2",
      "name": "Fetch Radiator Levels from AI",
      "type": "n8n-nodes-base.httpRequest",
      "position": [448, 0],
      "typeVersion": 4.2,
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Map Home Assistant sensors to rooms\nconst sensorMapping = {\n  'Badrum': 'sensor.bathroom_temperature_temperatur',\n  'Sovrum': 'sensor.bedroom_presence_temperatur', \n  'Kontor': 'sensor.office_temperatur',\n  'Vardagsrum': 'sensor.kitchen_temperatur'\n};\n\nconst haStates = $('Fetch Home Assistant States').all();\nconst aiState = $('Fetch Radiator Levels from AI').first().json;\n\n// Get outdoor temp from AI service\nconst outdoor_temp = aiState.weather?.outdoor_temp || 5;\nconst forecast_temp = aiState.weather?.forecast_3h || outdoor_temp;\n\nconst payloads = [];\n\n// For each room, build training payload\nfor (const [room, targetTemp] of Object.entries({\n  'Badrum': 22.5,\n  'Sovrum': 20,\n  'Kontor': 20,\n  'Vardagsrum': 21\n})) {\n  // Find temperature sensor in HA\n  const sensorId = sensorMapping[room];\n  const tempSensor = haStates.find(s => s.json.entity_id === sensorId);\n  \n  if (!tempSensor) {\n    console.log(`Warning: Sensor ${sensorId} not found for ${room}`);\n    continue;\n  }\n  \n  const currentTemp = parseFloat(tempSensor.json.state);\n  \n  // Skip if temperature is null or invalid\n  if (!currentTemp || isNaN(currentTemp)) {\n    console.log(`Warning: Invalid temperature for ${room}`);\n    continue;\n  }\n  \n  // Get radiator level from AI service state (supports decimals)\n  const radiatorLevel = aiState.rooms?.[room]?.current_level || 0;\n  \n  payloads.push({\n    json: {\n      room: room,\n      current_temp: currentTemp,\n      target_temp: targetTemp,\n      radiator_level: radiatorLevel,\n      outdoor_temp: outdoor_temp,\n      forecast_temp: forecast_temp,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nreturn payloads;"
      },
      "id": "REPLACE_WITH_UUID_3",
      "name": "Build Training Payloads",
      "type": "n8n-nodes-base.code",
      "position": [672, 0],
      "typeVersion": 2
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.AI_SERVICE_URL }}/train",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "id": "REPLACE_WITH_UUID_4",
      "name": "Train AI Model",
      "type": "n8n-nodes-base.httpRequest",
      "position": [880, 0],
      "typeVersion": 4.2
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 4
            }
          ]
        }
      },
      "id": "REPLACE_WITH_UUID_5",
      "name": "Prediction Schedule (Every 4h)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "position": [0, 304],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "url": "={{ $env.HOME_ASSISTANT_URL }}/api/states",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.HOME_ASSISTANT_TOKEN }}"
            }
          ]
        },
        "options": {}
      },
      "id": "REPLACE_WITH_UUID_6",
      "name": "Fetch HA States for Prediction",
      "type": "n8n-nodes-base.httpRequest",
      "position": [224, 304],
      "typeVersion": 4.2
    },
    {
      "parameters": {
        "jsCode": "// --- Room sensor mapping (same as training) ---\nconst sensorMapping = {\n  'Badrum': 'sensor.bathroom_temperature_temperatur',\n  'Sovrum': 'sensor.bedroom_presence_temperatur',\n  'Kontor': 'sensor.office_temperatur',\n  'Vardagsrum': 'sensor.kitchen_temperatur'\n};\n\n// --- Target temps ---\nconst targetTemps = { Badrum: 22.5, Sovrum: 20, Kontor: 20, Vardagsrum: 21 };\n\n// ===== 1) GET HA STATES EXPLICITLY FROM THE NODE =====\nlet haItems = $('Fetch HA States for Prediction').all();\n// If the HTTP node returned a single item containing an array, normalize it:\nif (haItems.length === 1 && Array.isArray(haItems[0].json)) {\n  haItems = haItems[0].json.map(e => ({ json: e }));\n}\n\n// Build a fast lookup: entity_id -> item.json\nconst haById = new Map();\nfor (const it of haItems) {\n  const id = it?.json?.entity_id;\n  if (id) haById.set(id, it.json);\n}\n\n// ===== 2) GET AI STATE EXPLICITLY AND UNWRAP IF ARRAY =====\nconst aiRaw = $('Fetch Radiator Levels from AI for Prediction').first()?.json;\nconst aiState = Array.isArray(aiRaw) ? (aiRaw[0] || {}) : (aiRaw || {});\n\n// Weather (optional)\nconst outdoor_temp = aiState.weather?.outdoor_temp ?? null;\nconst forecast_temp = aiState.weather?.forecast_3h ?? outdoor_temp;\n\n// ===== 3) BUILD PREDICTION PAYLOADS =====\nconst payloads = [];\n\nfor (const [room, sensorId] of Object.entries(sensorMapping)) {\n  const ent = haById.get(sensorId);\n  if (!ent) {\n    console.log(`âš ï¸ Missing HA sensor ${sensorId} for ${room}`);\n    continue;\n  }\n\n  const currentTemp = parseFloat(ent.state);\n  if (Number.isNaN(currentTemp)) {\n    console.log(`âš ï¸ Non-numeric state for ${sensorId}: ${ent.state}`);\n    continue;\n  }\n\n  const target_temp = targetTemps[room];\n\n  // Pull current level from AI state -> rooms[room].current_level\n  // Note: radiator_level now supports decimals (e.g., 2.5, 4.0)\n  const radiator_level = aiState.rooms?.[room]?.current_level ?? 0;\n\n  payloads.push({\n    json: {\n      room,\n      current_temp: currentTemp,\n      target_temp,\n      radiator_level,\n      outdoor_temp,\n      forecast_temp,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\n// If nothing matched, return debug instead of empty (so n8n continues)\nif (payloads.length === 0) {\n  return [{\n    json: {\n      error: \"No matching payloads built\",\n      ha_items: haItems.length,\n      ai_state_keys: Object.keys(aiState || {}),\n      ai_rooms: Object.keys(aiState.rooms || {}),\n    }\n  }];\n}\n\nreturn payloads;\n"
      },
      "id": "REPLACE_WITH_UUID_7",
      "name": "Build Prediction Payloads",
      "type": "n8n-nodes-base.code",
      "position": [672, 304],
      "typeVersion": 2
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.AI_SERVICE_URL }}/predict",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "id": "REPLACE_WITH_UUID_8",
      "name": "Get AI Predictions",
      "type": "n8n-nodes-base.httpRequest",
      "position": [880, 304],
      "typeVersion": 4.2
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "REPLACE_WITH_UUID_9",
      "name": "Training Schedule (Every 15min)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "position": [0, 0],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "jsCode": "// Collect all predictions\nconst predictions = $input.all();\nconst inputs = $('Build Prediction Payloads').all();\n\nlet message = 'ðŸ¤– *Radiator AI*\\n';\nlet hasChanges = false;\n\nfor (let i = 0; i < predictions.length; i++) {\n  const pred = predictions[i].json;\n  const input = inputs[i]?.json;\n  \n  if (!input) continue;\n  \n  const room = input.room;\n  const currentTemp = input.current_temp;\n  const targetTemp = input.target_temp;\n  const recommended = pred.recommended;\n  const currentLevel = input.radiator_level;\n  const delta = (currentTemp - targetTemp).toFixed(1);\n  \n  // Only show if there's a recommended change (account for decimal precision)\n  if (Math.abs(recommended - currentLevel) > 0.1) {\n    hasChanges = true;\n    const change = recommended > currentLevel ? 'ðŸ“ˆ' : 'ðŸ“‰';\n    message += `\\n${change} *${room}*: ${currentLevel} â†’ ${recommended}`;\n    message += ` (${delta > 0 ? '+' : ''}${delta}Â°C)`;\n  }\n}\n\n// Only return a message if there are changes\nif (hasChanges) {\n  return [{ json: { text: message } }];\n} else {\n  return [];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1104, 304],
      "id": "REPLACE_WITH_UUID_10",
      "name": "Format Telegram Message",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "={{ $json.text }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1552, 304],
      "id": "REPLACE_WITH_UUID_11",
      "name": "Send Telegram Notification",
      "webhookId": "REPLACE_WITH_YOUR_WEBHOOK_ID",
      "credentials": {
        "telegramApi": {
          "id": "REPLACE_WITH_YOUR_TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram Bot API"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "filter-has-message",
              "leftValue": "={{ $json }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1328, 304],
      "id": "REPLACE_WITH_UUID_12",
      "name": "Check If Has Changes"
    },
    {
      "parameters": {
        "url": "={{ $env.AI_SERVICE_URL }}/",
        "options": {}
      },
      "id": "REPLACE_WITH_UUID_13",
      "name": "Fetch Radiator Levels from AI for Prediction",
      "type": "n8n-nodes-base.httpRequest",
      "position": [448, 304],
      "typeVersion": 4.2,
      "executeOnce": true
    }
  ],
  "pinData": {},
  "connections": {
    "Fetch Home Assistant States": {
      "main": [[{"node": "Fetch Radiator Levels from AI", "type": "main", "index": 0}]]
    },
    "Fetch Radiator Levels from AI": {
      "main": [[{"node": "Build Training Payloads", "type": "main", "index": 0}]]
    },
    "Build Training Payloads": {
      "main": [[{"node": "Train AI Model", "type": "main", "index": 0}]]
    },
    "Prediction Schedule (Every 4h)": {
      "main": [[{"node": "Fetch HA States for Prediction", "type": "main", "index": 0}]]
    },
    "Fetch HA States for Prediction": {
      "main": [[{"node": "Fetch Radiator Levels from AI for Prediction", "type": "main", "index": 0}]]
    },
    "Build Prediction Payloads": {
      "main": [[{"node": "Get AI Predictions", "type": "main", "index": 0}]]
    },
    "Training Schedule (Every 15min)": {
      "main": [[{"node": "Fetch Home Assistant States", "type": "main", "index": 0}]]
    },
    "Get AI Predictions": {
      "main": [[{"node": "Format Telegram Message", "type": "main", "index": 0}]]
    },
    "Format Telegram Message": {
      "main": [[{"node": "Check If Has Changes", "type": "main", "index": 0}]]
    },
    "Check If Has Changes": {
      "main": [[{"node": "Send Telegram Notification", "type": "main", "index": 0}]]
    },
    "Fetch Radiator Levels from AI for Prediction": {
      "main": [[{"node": "Build Prediction Payloads", "type": "main", "index": 0}]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "REPLACE_WITH_NEW_VERSION_ID",
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "REPLACE_WITH_YOUR_INSTANCE_ID"
  },
  "id": "REPLACE_WITH_YOUR_WORKFLOW_ID",
  "tags": []
}
